// Generated by CoffeeScript 1.9.3
(function() {
  var Bottleneck,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice;

  Bottleneck = (function() {
    var e;

    Bottleneck.strategy = Bottleneck.prototype.strategy = {
      LEAK: 1,
      OVERFLOW: 2,
      BLOCK: 3
    };

    Bottleneck.Cluster = Bottleneck.prototype.Cluster = require("./Cluster");

    Bottleneck.Promise = Bottleneck.prototype.Promise = (function() {
      try {
        return require("bluebird");
      } catch (_error) {
        e = _error;
        return typeof Promise !== "undefined" && Promise !== null ? Promise : function() {
          throw new Error("Bottleneck: install 'bluebird' or use Node 0.12 or higher for Promise support");
        };
      }
    })();

    function Bottleneck(maxNb, minTime, highWater, strategy) {
      this.maxNb = maxNb != null ? maxNb : 0;
      this.minTime = minTime != null ? minTime : 0;
      this.highWater = highWater != null ? highWater : 0;
      this.strategy = strategy != null ? strategy : Bottleneck.prototype.strategy.LEAK;
      this.submit = bind(this.submit, this);
      this._nextRequest = Date.now();
      this._nbRunning = 0;
      this._queue = [];
      this._timeouts = [];
      this._unblockTime = 0;
      this.penalty = (15 * this.minTime) || 5000;
      this.interrupt = false;
      this.reservoir = null;
      this.limiter = null;
    }

    Bottleneck.prototype.chain = function(limiter) {
      this.limiter = limiter;
      return this;
    };

    Bottleneck.prototype.isBlocked = function() {
      return this._unblockTime >= Date.now();
    };

    Bottleneck.prototype.check = function() {
      return (this._nbRunning < this.maxNb || this.maxNb <= 0) && (this._nextRequest - Date.now()) <= 0 && ((this.reservoir == null) || this.reservoir > 0);
    };

    Bottleneck.prototype._tryToRun = function() {
      var done, index, next, wait;
      if ((this._nbRunning < this.maxNb || this.maxNb <= 0) && this._queue.length > 0 && ((this.reservoir == null) || this.reservoir > 0)) {
        this._nbRunning++;
        if (this.reservoir != null) {
          this.reservoir--;
        }
        wait = Math.max(this._nextRequest - Date.now(), 0);
        this._nextRequest = Date.now() + wait + this.minTime;
        next = this._queue.shift();
        done = false;
        index = -1 + this._timeouts.push(setTimeout((function(_this) {
          return function() {
            var completed;
            completed = function() {
              var ref;
              if (!done) {
                done = true;
                delete _this._timeouts[index];
                _this._nbRunning--;
                _this._tryToRun();
                if (!_this.interrupt) {
                  return (ref = next.cb) != null ? ref.apply({}, Array.prototype.slice.call(arguments, 0)) : void 0;
                }
              }
            };
            if (_this.limiter != null) {
              return _this.limiter.submit.apply(_this.limiter, Array.prototype.concat.call(next.task, next.args, completed));
            } else {
              return next.task.apply({}, next.args.concat(completed));
            }
          };
        })(this), wait));
        return true;
      } else {
        return false;
      }
    };

    Bottleneck.prototype.submit = function() {
      var args, cb, i, reachedHighWaterMark, task;
      task = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), cb = arguments[i++];
      reachedHighWaterMark = this.highWater > 0 && this._queue.length === this.highWater;
      if (this.strategy === Bottleneck.prototype.strategy.BLOCK && (reachedHighWaterMark || this.isBlocked())) {
        this._unblockTime = Date.now() + this.penalty;
        this._nextRequest = this._unblockTime + this.minTime;
        this._queue = [];
        return true;
      } else if (reachedHighWaterMark) {
        if (this.strategy === Bottleneck.prototype.strategy.LEAK) {
          this._queue.shift();
        } else if (this.strategy === Bottleneck.prototype.strategy.OVERFLOW) {
          return reachedHighWaterMark;
        }
      }
      this._queue.push({
        task: task,
        args: args,
        cb: cb
      });
      this._tryToRun();
      return reachedHighWaterMark;
    };

    Bottleneck.prototype.schedule = function() {
      var args, task, wrapped;
      task = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      wrapped = function(cb) {
        return (task.apply({}, args)).then(function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return cb.apply({}, Array.prototype.concat.call([], null, args));
        })["catch"](function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return cb.apply({}, Array.prototype.concat.call({}, args));
        });
      };
      return new Bottleneck.prototype.Promise((function(_this) {
        return function(resolve, reject) {
          return _this.submit.apply({}, Array.prototype.concat.call(wrapped, function() {
            var args, error;
            error = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            return (error != null ? reject : resolve).apply({}, args);
          }));
        };
      })(this));
    };

    Bottleneck.prototype.changeSettings = function(maxNb, minTime, highWater, strategy) {
      this.maxNb = maxNb != null ? maxNb : this.maxNb;
      this.minTime = minTime != null ? minTime : this.minTime;
      this.highWater = highWater != null ? highWater : this.highWater;
      this.strategy = strategy != null ? strategy : this.strategy;
      while (this._tryToRun()) {}
      return this;
    };

    Bottleneck.prototype.changePenalty = function(penalty) {
      this.penalty = penalty != null ? penalty : this.penalty;
      return this;
    };

    Bottleneck.prototype.changeReservoir = function(reservoir) {
      this.reservoir = reservoir;
      while (this._tryToRun()) {}
      return this;
    };

    Bottleneck.prototype.incrementReservoir = function(incr) {
      if (incr == null) {
        incr = 0;
      }
      this.changeReservoir(this.reservoir + incr);
      return this;
    };

    Bottleneck.prototype.stopAll = function(interrupt) {
      var a, i, len, ref;
      this.interrupt = interrupt != null ? interrupt : this.interrupt;
      ref = this._timeouts;
      for (i = 0, len = ref.length; i < len; i++) {
        a = ref[i];
        clearTimeout(a);
      }
      this._tryToRun = function() {};
      this.submit = function() {
        return false;
      };
      return this.check = function() {
        return false;
      };
    };

    return Bottleneck;

  })();

  module.exports = Bottleneck;

}).call(this);
